import requests
import pandas as pd
from sklearn import preprocessing
import itertools
import numpy as np
from scipy.spatial.distance import pdist, squareform
import random

#Other stuff I used
#import time
#from scipy.special import erf
#import matplotlib.pyplot as plt

#This just gets rid of the warnings that have been annoying me
import warnings
warnings.filterwarnings("ignore")


#Normalize data frame where song features are stored
def normalizeDf(df):
	min_max_scaler = preprocessing.MinMaxScaler()
	for i in allFeatures: #Change for general df
		df[i] = pd.DataFrame(min_max_scaler.fit_transform(df[i]))
	return df.set_index("songid")

#Given those variables, it creates an array where the ith position is the chance the current song goes to song i
def createWeightVector(df, currSong, finalSong, time):
	weightArrayLin = np.zeros(df.shape[0])
	for i in range(df.shape[0]):
		weightArrayLin[i] = songWeight(currSong, df.ix[i], finalSong, time)
	return weightArrayLin

#Gives a weight for song1 -> song2. The algorithm is pretty random
def songWeight(currSong, nextSong, finalSong, time): #time is time remaining

	markerSong = currSong + (finalSong - currSong) / time
	dist = pdist([markerSong, nextSong], 'minkowski', 2)[0]

	variance = 0.01
	return np.exp(-dist**2 / (2*variance))


	# #Calculates pdf given all the variables. Ill need this later. Is there an easier way of doing this?
	# def calcPDF(val, mean, sd):
	# 	#Gets rid of some infinity problem im too lazy to figure out
	# 	if sd == 0:
	# 		return val == mean;
	# 	return np.exp(-1*(val - mean)**2/(2*sd**2))/np.sqrt(2*np.pi*sd**2)

	#2 methods (neither of them work)
	#	1)

	# #SD and Âµ for all the different metrics
	# standardDeviations = np.zeros(currSong.size)
	# means = np.zeros(currSong.size)

	# for i in range (0, currSong.size):
	# 	#this is just some bad formula that should make something that sorta goes from one song to another
	# 	#it should definitely be changed. this doesnt work
	# 	means[i] = currSong[i] + (currSong[i] - finalSong[i]) / time / 1000
	# 	standardDeviations[i] = np.abs((currSong[i] - finalSong[i]) / time / 1000)
	
	# #Array contains all the different PDFs for all the metrics
	# pdfVals = np.zeros(currSong.size)
	# for i in range (0, currSong.size):
	# 	pdfVals[i] = calcPDF(nextSong[i], means[i], standardDeviations[i])

	# return sum(pdfVals)#figure this out too

	#	2)

	# #distance between currSong and finalSong
	# distance = pdist([currSong, finalSong], 'minkowski', 2)[0]
	# sdConstant = 1 #this is here because I dont know how to sd
	
	# #circle stuff goes on here
	# leftWeight = calcPDF(pdist([currSong, nextSong], 'minkowski', 2)[0], distance / time, sdConstant)
	# rightWeight = calcPDF(pdist([nextSong, finalSong], 'minkowski', 2)[0], distance * (time - 1) / time, sdConstant)

	# return leftWeight * rightWeight

#Gives a random walk with t time. It can repeat songs still, weightArrayLin is the thing generated by create1DWeightArrayLin
def randomWalk(df, startIndex, endIndex, t, r = 2):
	walkPath = np.zeros((t,), dtype=np.int)

	#First song should be start song, last song should be end song
	walkPath[0] = staweightVector[walkPath[j]] = 0
		walkPath[i] = weightedChoice(weightVector)

	return walkPath
ngs
#Defines a choce functionrtIndex
	walkPath[-1] = endIndex

	for i in range(1,t-1):
		weightVector = createWeightVector(df, df.ix[walkPath[i-1]], df.ix[endIndex], t - i)
		weightVector[endIndex] = 0;
		#Remove last r so
		for j in range(max(i-r,0),i):
			 given weights. TODO make more varied weight functions
def weightedChoice(weights):
    totalWeight = np.sum(weights)
    if totalWeight == 0:
        return random.randint(0,len(weights))
    #Subtract the weight from choice at each step and return the song it gets below 0 at
    choice = random.random() * totalWeight
    for i in range(len(weights)):
        choice -= weights[i]
        if choice <= 0:
            return i
    return len(weights) - 1


#Creates a song list given a random walk on df
def toSongList(randomWalk, df):
	songList = []
	for i in range(len(randomWalk)):
		songList += [df.ix[int(randomWalk[i])].name]
	return songList

# featuredPlaylists = requests.get("https://api.spotify.com/v1/browse/featured-playlists", headers=access_header).json()["playlists"]["items"]
# allFeaturedPlaylistData = {}
# for i in featuredPlaylists:
# 	tracks = requests.get(i["href"] + "/tracks", headers=access_header).json()["items"]
# 	tracksList = []
# 	for j in tracks:
# 		tracksList.append(j["track"]["id"])
# 	allFeaturedPlaylistData[i["id"]] = gd.getSongs(tracksList)


#To pass in data, pass in a df with song ids and normalized data
allFeatures = ["danceability", "energy", "key", "loudness", "speechiness", "acousticness",
				 "instrumentalness", "liveness", "valence", "tempo", "time_signature"]

df = pd.read_csv('../data/song_data_unique.csv')
del df['category']
del df['popularity']
del df['song_title']
del df['artist_name']
ndf = normalizeDf(df)

#wal = createWeightVector(ndf.ix[:150], ndf.ix[0], ndf.ix[100], 10)
rwl = randomWalk(ndf.ix[:8594], startIndex = 0, endIndex = 8593, t = 8)
sl = toSongList(rwl, ndf)

print(sl)
print(rwl)

#does it converge on the destination?
for i in range(rwl.size):
	print(pdist([ndf.ix[rwl[i]], ndf.ix[rwl[-1]]], 'minkowski', 2)[0])


#this is just a graph to help me out with something but now im confused
# dists = np.zeros(ndf.shape[0])
# for i in range(ndf.shape[0] - 1):
# 	dists[i] = pdist([ndf.ix[i], ndf.ix[1445]], 'minkowski', 2)[0]

# normDists = [(x - np.mean(dists)) / np.std(dists) for x in dists]
# uniDists = [(1 - erf(-x/np.sqrt(2)))/2 for x in normDists]

# print(plt.hist(uniDists, 50, facecolor = 'green', alpha = .75))
# plt.show()

#print("mean: ", np.mean(wal))
#print("variance: ", np.var(wal))
#print("elements > 0: ", len(wal[wal > 0]))

